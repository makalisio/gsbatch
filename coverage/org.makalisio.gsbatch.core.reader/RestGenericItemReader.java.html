<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RestGenericItemReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">gsbatch</a> &gt; <a href="index.source.html" class="el_package">org.makalisio.gsbatch.core.reader</a> &gt; <span class="el_source">RestGenericItemReader.java</span></div><h1>RestGenericItemReader.java</h1><pre class="source lang-java linenums">package org.makalisio.gsbatch.core.reader;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.jayway.jsonpath.Configuration;
import com.jayway.jsonpath.JsonPath;
import com.jayway.jsonpath.Option;
import lombok.extern.slf4j.Slf4j;
import org.makalisio.gsbatch.core.model.ColumnConfig;
import org.makalisio.gsbatch.core.model.GenericRecord;
import org.makalisio.gsbatch.core.model.RestConfig;
import org.makalisio.gsbatch.core.model.SourceConfig;
import org.springframework.batch.item.ItemStreamReader;
import org.springframework.http.*;
import org.springframework.retry.RetryPolicy;
import org.springframework.retry.backoff.FixedBackOffPolicy;
import org.springframework.retry.policy.SimpleRetryPolicy;
import org.springframework.retry.support.RetryTemplate;
import org.springframework.web.client.HttpStatusCodeException;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * REST API ItemReader with pagination, retry, and JSON extraction.
 *
 * &lt;p&gt;Features:&lt;/p&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;Paginated HTTP calls (PAGE_SIZE, OFFSET_LIMIT, CURSOR strategies)&lt;/li&gt;
 *   &lt;li&gt;Bind variable resolution (:paramName from jobParameters)&lt;/li&gt;
 *   &lt;li&gt;Environment variable resolution (${VAR})&lt;/li&gt;
 *   &lt;li&gt;JsonPath extraction from nested JSON responses&lt;/li&gt;
 *   &lt;li&gt;Automatic retry on transient HTTP errors (429, 503, 504)&lt;/li&gt;
 *   &lt;li&gt;Authentication (API_KEY, BEARER, OAUTH2)&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author Makalisio
 * @since 0.0.1
 */
<span class="nc" id="L45">@Slf4j</span>
public class RestGenericItemReader implements ItemStreamReader&lt;GenericRecord&gt; {

<span class="nc" id="L48">    private static final Pattern BIND_PARAM_PATTERN = Pattern.compile(&quot;(?&lt;![:])(:[a-zA-Z][a-zA-Z0-9_]*)&quot;);</span>
<span class="nc" id="L49">    private static final Pattern ENV_VAR_PATTERN = Pattern.compile(&quot;\\$\\{([^}]+)\\}&quot;);</span>
<span class="nc" id="L50">    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();</span>

    private final SourceConfig sourceConfig;
    private final RestConfig restConfig;
    private final Map&lt;String, Object&gt; jobParameters;
    private final RestTemplate restTemplate;
    private final RetryTemplate retryTemplate;
    private final Configuration jsonPathConfig;

    // Pagination state
<span class="nc" id="L60">    private int currentPage = 0;</span>
<span class="nc" id="L61">    private int currentOffset = 0;</span>
<span class="nc" id="L62">    private String currentCursor = null;</span>
<span class="nc" id="L63">    private Integer totalItems = null;</span>
<span class="nc" id="L64">    private int itemsRead = 0;</span>

    // Buffer for items from current page
<span class="nc" id="L67">    private Queue&lt;GenericRecord&gt; buffer = new LinkedList&lt;&gt;();</span>

    // Resolved values (computed once in open())
    private String resolvedUrl;
    private Map&lt;String, String&gt; resolvedQueryParams;
    private HttpHeaders resolvedHeaders;

    /**
     * @param sourceConfig    source configuration from YAML
     * @param restConfig      REST-specific configuration
     * @param jobParameters   job parameters for bind variable resolution
     * @param restTemplate    configured RestTemplate with auth interceptor
     * @param retryTemplate   configured RetryTemplate for transient errors
     */
    public RestGenericItemReader(SourceConfig sourceConfig,
                                 RestConfig restConfig,
                                 Map&lt;String, Object&gt; jobParameters,
                                 RestTemplate restTemplate,
<span class="nc" id="L85">                                 RetryTemplate retryTemplate) {</span>
<span class="nc" id="L86">        this.sourceConfig = sourceConfig;</span>
<span class="nc" id="L87">        this.restConfig = restConfig;</span>
<span class="nc" id="L88">        this.jobParameters = Collections.unmodifiableMap(jobParameters);</span>
<span class="nc" id="L89">        this.restTemplate = restTemplate;</span>
<span class="nc" id="L90">        this.retryTemplate = retryTemplate;</span>

        // JsonPath configuration: suppress exceptions, return null for missing paths
<span class="nc" id="L93">        this.jsonPathConfig = Configuration.builder()</span>
<span class="nc" id="L94">                .options(Option.SUPPRESS_EXCEPTIONS, Option.DEFAULT_PATH_LEAF_TO_NULL)</span>
<span class="nc" id="L95">                .build();</span>

<span class="nc" id="L97">        log.info(&quot;RestGenericItemReader initialized for source '{}'&quot;, sourceConfig.getName());</span>
<span class="nc" id="L98">    }</span>

    // ─────────────────────────────────────────────────────────────────────────
    //  ItemStreamReader implementation
    // ─────────────────────────────────────────────────────────────────────────

    @Override
    public void open(org.springframework.batch.item.ExecutionContext executionContext) {
<span class="nc" id="L106">        log.info(&quot;Opening REST reader for source '{}'&quot;, sourceConfig.getName());</span>

        // Resolve URL, query params, and headers once
<span class="nc" id="L109">        resolvedUrl = resolveVariables(restConfig.getUrl(), &quot;rest.url&quot;);</span>
<span class="nc" id="L110">        resolvedQueryParams = resolveQueryParams();</span>
<span class="nc" id="L111">        resolvedHeaders = buildHeaders();</span>

        // Reset pagination state
<span class="nc" id="L114">        currentPage = 0;</span>
<span class="nc" id="L115">        currentOffset = 0;</span>
<span class="nc" id="L116">        currentCursor = null;</span>
<span class="nc" id="L117">        itemsRead = 0;</span>
<span class="nc" id="L118">        buffer.clear();</span>

<span class="nc" id="L120">        log.info(&quot;REST reader opened - URL: {}, pagination: {}&quot;,</span>
<span class="nc" id="L121">                resolvedUrl, restConfig.getPagination().getStrategy());</span>
<span class="nc" id="L122">    }</span>

    @Override
    public GenericRecord read() throws Exception {
        // If buffer is empty, fetch next page
<span class="nc bnc" id="L127" title="All 2 branches missed.">        if (buffer.isEmpty()) {</span>
<span class="nc" id="L128">            fetchNextPage();</span>
        }

        // Poll next item from buffer (null if no more items)
<span class="nc" id="L132">        GenericRecord record = buffer.poll();</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">        if (record != null) {</span>
<span class="nc" id="L134">            itemsRead++;</span>
        }

<span class="nc" id="L137">        return record;</span>
    }

    @Override
    public void close() {
<span class="nc" id="L142">        log.info(&quot;Closing REST reader for source '{}' - total items read: {}&quot;,</span>
<span class="nc" id="L143">                sourceConfig.getName(), itemsRead);</span>
<span class="nc" id="L144">        buffer.clear();</span>
<span class="nc" id="L145">    }</span>

    // ─────────────────────────────────────────────────────────────────────────
    //  Pagination
    // ─────────────────────────────────────────────────────────────────────────

    private void fetchNextPage() {
<span class="nc" id="L152">        String strategy = restConfig.getPagination().getStrategy().toUpperCase();</span>

<span class="nc bnc" id="L154" title="All 2 branches missed.">        if (&quot;NONE&quot;.equals(strategy)) {</span>
            // Single call, no pagination
<span class="nc bnc" id="L156" title="All 2 branches missed.">            if (currentPage &gt; 0) {</span>
<span class="nc" id="L157">                return;  // Already fetched, no more pages</span>
            }
<span class="nc" id="L159">            fetchPage(buildUrl(resolvedUrl, resolvedQueryParams));</span>
<span class="nc" id="L160">            currentPage++;</span>
        }
<span class="nc bnc" id="L162" title="All 2 branches missed.">        else if (&quot;PAGE_SIZE&quot;.equals(strategy)) {</span>
<span class="nc" id="L163">            Map&lt;String, String&gt; pageParams = new HashMap&lt;&gt;(resolvedQueryParams);</span>
<span class="nc" id="L164">            pageParams.put(restConfig.getPagination().getPageParam(), String.valueOf(currentPage));</span>
<span class="nc" id="L165">            pageParams.put(restConfig.getPagination().getSizeParam(),</span>
<span class="nc" id="L166">                    String.valueOf(restConfig.getPagination().getPageSize()));</span>

<span class="nc" id="L168">            String pageUrl = buildUrl(resolvedUrl, pageParams);</span>
<span class="nc" id="L169">            List&lt;GenericRecord&gt; items = fetchPage(pageUrl);</span>

<span class="nc bnc" id="L171" title="All 2 branches missed.">            if (items.isEmpty()) {</span>
<span class="nc" id="L172">                log.debug(&quot;Page {} returned 0 items - end of pagination&quot;, currentPage);</span>
            } else {
<span class="nc" id="L174">                log.debug(&quot;Page {} fetched: {} items&quot;, currentPage, items.size());</span>
<span class="nc" id="L175">                currentPage++;</span>
            }
<span class="nc" id="L177">        }</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">        else if (&quot;OFFSET_LIMIT&quot;.equals(strategy)) {</span>
<span class="nc" id="L179">            Map&lt;String, String&gt; pageParams = new HashMap&lt;&gt;(resolvedQueryParams);</span>
<span class="nc" id="L180">            pageParams.put(restConfig.getPagination().getOffsetParam(), String.valueOf(currentOffset));</span>
<span class="nc" id="L181">            pageParams.put(restConfig.getPagination().getLimitParam(),</span>
<span class="nc" id="L182">                    String.valueOf(restConfig.getPagination().getPageSize()));</span>

<span class="nc" id="L184">            String pageUrl = buildUrl(resolvedUrl, pageParams);</span>
<span class="nc" id="L185">            List&lt;GenericRecord&gt; items = fetchPage(pageUrl);</span>

<span class="nc bnc" id="L187" title="All 2 branches missed.">            if (items.isEmpty()) {</span>
<span class="nc" id="L188">                log.debug(&quot;Offset {} returned 0 items - end of pagination&quot;, currentOffset);</span>
            } else {
<span class="nc" id="L190">                log.debug(&quot;Offset {} fetched: {} items&quot;, currentOffset, items.size());</span>
<span class="nc" id="L191">                currentOffset += items.size();</span>
            }
<span class="nc" id="L193">        }</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">        else if (&quot;CURSOR&quot;.equals(strategy)) {</span>
<span class="nc" id="L195">            Map&lt;String, String&gt; pageParams = new HashMap&lt;&gt;(resolvedQueryParams);</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">            if (currentCursor != null) {</span>
<span class="nc" id="L197">                pageParams.put(restConfig.getPagination().getCursorParam(), currentCursor);</span>
            }

<span class="nc" id="L200">            String pageUrl = buildUrl(resolvedUrl, pageParams);</span>
<span class="nc" id="L201">            List&lt;GenericRecord&gt; items = fetchPage(pageUrl);</span>

<span class="nc bnc" id="L203" title="All 2 branches missed.">            if (items.isEmpty()) {</span>
<span class="nc" id="L204">                log.debug(&quot;Cursor '{}' returned 0 items - end of pagination&quot;, currentCursor);</span>
            } else {
<span class="nc" id="L206">                log.debug(&quot;Cursor '{}' fetched: {} items&quot;, currentCursor, items.size());</span>
            }
<span class="nc" id="L208">        }</span>
        else {
<span class="nc" id="L210">            throw new UnsupportedOperationException(</span>
                    &quot;Pagination strategy not yet implemented: &quot; + strategy);
        }
<span class="nc" id="L213">    }</span>

    private List&lt;GenericRecord&gt; fetchPage(String url) {
<span class="nc" id="L216">        log.debug(&quot;Fetching page: {}&quot;, url);</span>

        // Execute HTTP request with retry
<span class="nc" id="L219">        String jsonResponse = retryTemplate.execute(context -&gt; {</span>
<span class="nc" id="L220">            ResponseEntity&lt;String&gt; response = restTemplate.exchange(</span>
<span class="nc" id="L221">                    url, HttpMethod.valueOf(restConfig.getMethod()),</span>
                    new HttpEntity&lt;&gt;(resolvedHeaders), String.class
            );

<span class="nc bnc" id="L225" title="All 2 branches missed.">            if (!response.getStatusCode().is2xxSuccessful()) {</span>
<span class="nc" id="L226">                throw new IllegalStateException(</span>
<span class="nc" id="L227">                        &quot;HTTP request failed with status: &quot; + response.getStatusCode());</span>
            }

<span class="nc" id="L230">            return response.getBody();</span>
        });

<span class="nc bnc" id="L233" title="All 4 branches missed.">        if (jsonResponse == null || jsonResponse.isBlank()) {</span>
<span class="nc" id="L234">            log.warn(&quot;Empty response from API&quot;);</span>
<span class="nc" id="L235">            return Collections.emptyList();</span>
        }

        // Extract total count if configured (for logging progress)
<span class="nc bnc" id="L239" title="All 4 branches missed.">        if (totalItems == null &amp;&amp; restConfig.getPagination().getTotalPath() != null) {</span>
            try {
<span class="nc" id="L241">                Object totalObj = JsonPath.using(jsonPathConfig)</span>
<span class="nc" id="L242">                        .parse(jsonResponse)</span>
<span class="nc" id="L243">                        .read(restConfig.getPagination().getTotalPath());</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">                if (totalObj instanceof Number) {</span>
<span class="nc" id="L245">                    totalItems = ((Number) totalObj).intValue();</span>
<span class="nc" id="L246">                    log.info(&quot;Total items to fetch: {}&quot;, totalItems);</span>
                }
<span class="nc" id="L248">            } catch (Exception e) {</span>
<span class="nc" id="L249">                log.warn(&quot;Could not extract total count from response&quot;, e);</span>
<span class="nc" id="L250">            }</span>
        }

        // Extract cursor for next page (if CURSOR strategy)
<span class="nc bnc" id="L254" title="All 2 branches missed.">        if (&quot;CURSOR&quot;.equalsIgnoreCase(restConfig.getPagination().getStrategy()) &amp;&amp;</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">                restConfig.getPagination().getCursorPath() != null) {</span>
            try {
<span class="nc" id="L257">                Object cursorObj = JsonPath.using(jsonPathConfig)</span>
<span class="nc" id="L258">                        .parse(jsonResponse)</span>
<span class="nc" id="L259">                        .read(restConfig.getPagination().getCursorPath());</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">                currentCursor = cursorObj != null ? cursorObj.toString() : null;</span>
<span class="nc" id="L261">                log.debug(&quot;Next cursor: {}&quot;, currentCursor);</span>
<span class="nc" id="L262">            } catch (Exception e) {</span>
<span class="nc" id="L263">                log.warn(&quot;Could not extract cursor from response&quot;, e);</span>
<span class="nc" id="L264">                currentCursor = null;</span>
<span class="nc" id="L265">            }</span>
        }

        // Extract items array from JSON
<span class="nc" id="L269">        List&lt;Map&lt;String, Object&gt;&gt; jsonItems = extractItems(jsonResponse);</span>
<span class="nc" id="L270">        log.debug(&quot;Extracted {} items from JSON&quot;, jsonItems.size());</span>

        // Convert JSON items to GenericRecords
<span class="nc" id="L273">        List&lt;GenericRecord&gt; records = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">        for (Map&lt;String, Object&gt; jsonItem : jsonItems) {</span>
<span class="nc" id="L275">            GenericRecord record = convertJsonToRecord(jsonItem);</span>
<span class="nc" id="L276">            records.add(record);</span>
<span class="nc" id="L277">        }</span>

<span class="nc" id="L279">        buffer.addAll(records);</span>
<span class="nc" id="L280">        return records;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private List&lt;Map&lt;String, Object&gt;&gt; extractItems(String jsonResponse) {
        try {
<span class="nc" id="L286">            Object extracted = JsonPath.using(jsonPathConfig)</span>
<span class="nc" id="L287">                    .parse(jsonResponse)</span>
<span class="nc" id="L288">                    .read(restConfig.getDataPath());</span>

<span class="nc bnc" id="L290" title="All 2 branches missed.">            if (extracted == null) {</span>
<span class="nc" id="L291">                log.warn(&quot;JsonPath '{}' returned null&quot;, restConfig.getDataPath());</span>
<span class="nc" id="L292">                return Collections.emptyList();</span>
            }

<span class="nc bnc" id="L295" title="All 2 branches missed.">            if (extracted instanceof List) {</span>
<span class="nc" id="L296">                return (List&lt;Map&lt;String, Object&gt;&gt;) extracted;</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">            } else if (extracted instanceof Map) {</span>
                // Single item wrapped in object - wrap it in a list
<span class="nc" id="L299">                return List.of((Map&lt;String, Object&gt;) extracted);</span>
            } else {
<span class="nc" id="L301">                log.warn(&quot;Unexpected type from JsonPath: {}&quot;, extracted.getClass());</span>
<span class="nc" id="L302">                return Collections.emptyList();</span>
            }
<span class="nc" id="L304">        } catch (Exception e) {</span>
<span class="nc" id="L305">            log.error(&quot;Failed to extract items from JSON using path: {}&quot;,</span>
<span class="nc" id="L306">                    restConfig.getDataPath(), e);</span>
<span class="nc" id="L307">            return Collections.emptyList();</span>
        }
    }

    // ─────────────────────────────────────────────────────────────────────────
    //  JSON to GenericRecord conversion
    // ─────────────────────────────────────────────────────────────────────────

    private GenericRecord convertJsonToRecord(Map&lt;String, Object&gt; jsonItem) {
<span class="nc" id="L316">        Map&lt;String, Object&gt; recordData = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L318" title="All 2 branches missed.">        for (ColumnConfig column : sourceConfig.getColumns()) {</span>
<span class="nc" id="L319">            String columnName = column.getName();</span>
<span class="nc" id="L320">            String jsonPathExpr = column.getJsonPath();</span>

            Object value;
<span class="nc bnc" id="L323" title="All 4 branches missed.">            if (jsonPathExpr != null &amp;&amp; !jsonPathExpr.isBlank()) {</span>
                // Use custom JsonPath expression
<span class="nc" id="L325">                value = JsonPath.using(jsonPathConfig)</span>
<span class="nc" id="L326">                        .parse(jsonItem)</span>
<span class="nc" id="L327">                        .read(jsonPathExpr);</span>
            } else {
                // Direct mapping: column name = JSON key
<span class="nc" id="L330">                value = jsonItem.get(columnName);</span>
            }

            // Type conversion
<span class="nc" id="L334">            Object convertedValue = convertValue(value, column);</span>
<span class="nc" id="L335">            recordData.put(columnName, convertedValue);</span>
<span class="nc" id="L336">        }</span>

<span class="nc" id="L338">        return new GenericRecord(recordData);</span>
    }

    private Object convertValue(Object value, ColumnConfig column) {
<span class="nc bnc" id="L342" title="All 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L343">            return null;</span>
        }

<span class="nc" id="L346">        String type = column.getType().toUpperCase();</span>

        try {
<span class="nc bnc" id="L349" title="All 7 branches missed.">            switch (type) {</span>
                case &quot;STRING&quot;:
                    // Map/List from JSON must be serialized as valid JSON, not via toString()
<span class="nc bnc" id="L352" title="All 4 branches missed.">                    if (value instanceof Map || value instanceof List) {</span>
                        try {
<span class="nc" id="L354">                            return OBJECT_MAPPER.writeValueAsString(value);</span>
<span class="nc" id="L355">                        } catch (Exception e) {</span>
<span class="nc" id="L356">                            log.warn(&quot;Failed to serialize JSON value for column {}: {}&quot;,</span>
<span class="nc" id="L357">                                    column.getName(), e.getMessage());</span>
<span class="nc" id="L358">                            return value.toString();</span>
                        }
                    }
<span class="nc" id="L361">                    return value.toString();</span>

                case &quot;INTEGER&quot;:
                case &quot;LONG&quot;:
<span class="nc bnc" id="L365" title="All 2 branches missed.">                    if (value instanceof Number) {</span>
<span class="nc" id="L366">                        return ((Number) value).longValue();</span>
                    }
<span class="nc" id="L368">                    return Long.parseLong(value.toString());</span>

                case &quot;DECIMAL&quot;:
                case &quot;DOUBLE&quot;:
<span class="nc bnc" id="L372" title="All 2 branches missed.">                    if (value instanceof Number) {</span>
<span class="nc" id="L373">                        return ((Number) value).doubleValue();</span>
                    }
<span class="nc" id="L375">                    return Double.parseDouble(value.toString());</span>

                case &quot;BOOLEAN&quot;:
<span class="nc bnc" id="L378" title="All 2 branches missed.">                    if (value instanceof Boolean) {</span>
<span class="nc" id="L379">                        return value;</span>
                    }
<span class="nc" id="L381">                    return Boolean.parseBoolean(value.toString());</span>

                case &quot;DATE&quot;:
<span class="nc" id="L384">                    String dateStr = value.toString();</span>
<span class="nc" id="L385">                    String format = column.getFormat();</span>
<span class="nc bnc" id="L386" title="All 4 branches missed.">                    if (format != null &amp;&amp; !format.isBlank()) {</span>
<span class="nc" id="L387">                        return LocalDate.parse(dateStr, DateTimeFormatter.ofPattern(format));</span>
                    }
<span class="nc" id="L389">                    return LocalDate.parse(dateStr);</span>

                case &quot;DATETIME&quot;:
<span class="nc" id="L392">                    String datetimeStr = value.toString();</span>
<span class="nc" id="L393">                    String datetimeFormat = column.getFormat();</span>
<span class="nc bnc" id="L394" title="All 4 branches missed.">                    if (datetimeFormat != null &amp;&amp; !datetimeFormat.isBlank()) {</span>
<span class="nc" id="L395">                        return LocalDateTime.parse(datetimeStr,</span>
<span class="nc" id="L396">                                DateTimeFormatter.ofPattern(datetimeFormat));</span>
                    }
<span class="nc" id="L398">                    return LocalDateTime.parse(datetimeStr);</span>

                default:
<span class="nc" id="L401">                    return value;</span>
            }
<span class="nc" id="L403">        } catch (Exception e) {</span>
<span class="nc" id="L404">            log.warn(&quot;Failed to convert value '{}' to type {} for column {}: {}&quot;,</span>
<span class="nc" id="L405">                    value, type, column.getName(), e.getMessage());</span>
<span class="nc" id="L406">            return value;  // Return as-is if conversion fails</span>
        }
    }

    // ─────────────────────────────────────────────────────────────────────────
    //  URL building
    // ─────────────────────────────────────────────────────────────────────────

    private String buildUrl(String baseUrl, Map&lt;String, String&gt; queryParams) {
<span class="nc" id="L415">        UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(baseUrl);</span>

<span class="nc bnc" id="L417" title="All 2 branches missed.">        for (Map.Entry&lt;String, String&gt; param : queryParams.entrySet()) {</span>
<span class="nc" id="L418">            builder.queryParam(param.getKey(), param.getValue());</span>
<span class="nc" id="L419">        }</span>

<span class="nc" id="L421">        return builder.toUriString();</span>
    }

    // ─────────────────────────────────────────────────────────────────────────
    //  Variable resolution (bind variables + env vars)
    // ─────────────────────────────────────────────────────────────────────────

    private String resolveVariables(String input, String context) {
<span class="nc bnc" id="L429" title="All 2 branches missed.">        if (input == null) {</span>
<span class="nc" id="L430">            return null;</span>
        }

        // Step 1: Resolve bind variables (:paramName)
<span class="nc" id="L434">        String resolved = resolveBindVariables(input, context);</span>

        // Step 2: Resolve environment variables (${VAR})
<span class="nc" id="L437">        resolved = resolveEnvVariables(resolved, context);</span>

<span class="nc" id="L439">        return resolved;</span>
    }

    private String resolveBindVariables(String input, String context) {
<span class="nc" id="L443">        Matcher matcher = BIND_PARAM_PATTERN.matcher(input);</span>
<span class="nc" id="L444">        StringBuffer sb = new StringBuffer();</span>

<span class="nc bnc" id="L446" title="All 2 branches missed.">        while (matcher.find()) {</span>
<span class="nc" id="L447">            String paramName = matcher.group(1).substring(1);  // Remove &quot;:&quot;</span>

<span class="nc bnc" id="L449" title="All 2 branches missed.">            if (!jobParameters.containsKey(paramName)) {</span>
<span class="nc" id="L450">                throw new IllegalStateException(String.format(</span>
                        &quot;Bind variable not found in jobParameters [%s]: ':%s'%n&quot; +
                                &quot;Available parameters: %s&quot;,
<span class="nc" id="L453">                        context, paramName, jobParameters.keySet()</span>
                ));
            }

<span class="nc" id="L457">            Object value = jobParameters.get(paramName);</span>
<span class="nc" id="L458">            matcher.appendReplacement(sb, Matcher.quoteReplacement(value.toString()));</span>
<span class="nc" id="L459">        }</span>

<span class="nc" id="L461">        matcher.appendTail(sb);</span>
<span class="nc" id="L462">        return sb.toString();</span>
    }

    private String resolveEnvVariables(String input, String context) {
<span class="nc" id="L466">        Matcher matcher = ENV_VAR_PATTERN.matcher(input);</span>
<span class="nc" id="L467">        StringBuffer sb = new StringBuffer();</span>

<span class="nc bnc" id="L469" title="All 2 branches missed.">        while (matcher.find()) {</span>
<span class="nc" id="L470">            String varName = matcher.group(1);</span>
<span class="nc" id="L471">            String envValue = System.getenv(varName);</span>

<span class="nc bnc" id="L473" title="All 2 branches missed.">            if (envValue == null) {</span>
<span class="nc" id="L474">                throw new IllegalStateException(String.format(</span>
                        &quot;Environment variable not found [%s]: ${%s}%n&quot; +
                                &quot;Set it before running the job: export %s=&lt;value&gt;&quot;,
                        context, varName, varName
                ));
            }

<span class="nc" id="L481">            matcher.appendReplacement(sb, Matcher.quoteReplacement(envValue));</span>
<span class="nc" id="L482">        }</span>

<span class="nc" id="L484">        matcher.appendTail(sb);</span>
<span class="nc" id="L485">        return sb.toString();</span>
    }

    private Map&lt;String, String&gt; resolveQueryParams() {
<span class="nc" id="L489">        Map&lt;String, String&gt; resolved = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L491" title="All 2 branches missed.">        for (Map.Entry&lt;String, String&gt; entry : restConfig.getQueryParams().entrySet()) {</span>
<span class="nc" id="L492">            String key = entry.getKey();</span>
<span class="nc" id="L493">            String value = resolveVariables(entry.getValue(), &quot;rest.queryParams.&quot; + key);</span>
<span class="nc" id="L494">            resolved.put(key, value);</span>
<span class="nc" id="L495">        }</span>

<span class="nc" id="L497">        return resolved;</span>
    }

    private HttpHeaders buildHeaders() {
<span class="nc" id="L501">        HttpHeaders headers = new HttpHeaders();</span>

<span class="nc bnc" id="L503" title="All 2 branches missed.">        for (Map.Entry&lt;String, String&gt; entry : restConfig.getHeaders().entrySet()) {</span>
<span class="nc" id="L504">            String key = entry.getKey();</span>
<span class="nc" id="L505">            String value = resolveVariables(entry.getValue(), &quot;rest.headers.&quot; + key);</span>
<span class="nc" id="L506">            headers.set(key, value);</span>
<span class="nc" id="L507">        }</span>

<span class="nc" id="L509">        return headers;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>