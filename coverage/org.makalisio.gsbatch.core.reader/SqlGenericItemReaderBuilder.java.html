<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SqlGenericItemReaderBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">gsbatch</a> &gt; <a href="index.source.html" class="el_package">org.makalisio.gsbatch.core.reader</a> &gt; <span class="el_source">SqlGenericItemReaderBuilder.java</span></div><h1>SqlGenericItemReaderBuilder.java</h1><pre class="source lang-java linenums">package org.makalisio.gsbatch.core.reader;

import lombok.extern.slf4j.Slf4j;
import org.makalisio.gsbatch.core.model.ColumnConfig;
import org.makalisio.gsbatch.core.model.GenericRecord;
import org.makalisio.gsbatch.core.model.SourceConfig;
import org.springframework.batch.item.database.JdbcCursorItemReader;
import org.springframework.batch.item.database.builder.JdbcCursorItemReaderBuilder;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Component;

import javax.sql.DataSource;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;

/**
 * Builder for SQL readers based on external {@code .sql} files.
 *
 * &lt;h2&gt;Execution flow&lt;/h2&gt;
 * &lt;pre&gt;
 *   orders.yml
 *     sqlDirectory: /opt/sql
 *     sqlFile: orders.sql         ──► SqlFileLoader.load()
 *                                         │
 *                                         ├─ reads orders.sql
 *                                         ├─ parses :variables
 *                                         ├─ resolves from jobParameters
 *                                         └─ returns SQL(?) + PreparedStatementSetter
 *                                                     │
 *                                         JdbcCursorItemReader
 *                                            .sql(executableSql)
 *                                            .preparedStatementSetter(setter)
 * &lt;/pre&gt;
 *
 * &lt;h2&gt;Example SQL file&lt;/h2&gt;
 * &lt;pre&gt;
 *   SELECT order_id, customer_id, amount, currency
 *   FROM   ORDERS
 *   WHERE  status     = :status
 *     AND  trade_date = :process_date
 *   ORDER BY order_id
 * &lt;/pre&gt;
 *
 * &lt;h2&gt;Launch&lt;/h2&gt;
 * &lt;pre&gt;
 *   java -jar app.jar sourceName=orders status=NEW process_date=2024-01-15
 * &lt;/pre&gt;
 *
 * @author Makalisio
 * @since 0.0.1
 */
<span class="fc" id="L56">@Slf4j</span>
@Component
public class SqlGenericItemReaderBuilder {

    private final SqlFileLoader sqlFileLoader;
    private final DataSource defaultDataSource;
    private final BeanFactory beanFactory;

    /**
     * @param sqlFileLoader     SQL file loader with bind variable resolution
     * @param defaultDataSource primary DataSource (auto-configured by Spring Boot)
     * @param beanFactory       for resolving named DataSources (multi-DB)
     */
    public SqlGenericItemReaderBuilder(SqlFileLoader sqlFileLoader,
                                       DataSource defaultDataSource,
<span class="nc" id="L71">                                       BeanFactory beanFactory) {</span>
<span class="nc" id="L72">        this.sqlFileLoader = sqlFileLoader;</span>
<span class="nc" id="L73">        this.defaultDataSource = defaultDataSource;</span>
<span class="nc" id="L74">        this.beanFactory = beanFactory;</span>
<span class="nc" id="L75">        log.info(&quot;SqlGenericItemReaderBuilder initialized&quot;);</span>
<span class="nc" id="L76">    }</span>

    /**
     * Builds a {@link JdbcCursorItemReader} for a SQL source.
     *
     * &lt;p&gt;The SQL is read from the file {@code sqlDirectory/sqlFile} defined in the YAML.
     * Variables {@code :paramName} are resolved from {@code jobParameters}.&lt;/p&gt;
     *
     * @param config        the YAML source configuration
     * @param jobParameters all job parameters (contains bind variable values)
     * @return JDBC reader configured and ready for Spring Batch
     * @throws SqlFileLoader.SqlFileException if the file is not found or a parameter is missing
     */
    public JdbcCursorItemReader&lt;GenericRecord&gt; build(SourceConfig config,
                                                      Map&lt;String, Object&gt; jobParameters) {
<span class="nc" id="L91">        log.info(&quot;Building SQL reader for source '{}' - file: {}/{}&quot;,</span>
<span class="nc" id="L92">                config.getName(), config.getSqlDirectory(), config.getSqlFile());</span>

        // ── 1. Load SQL + resolve bind variables ─────────────────────────────
<span class="nc" id="L95">        SqlFileLoader.LoadedSql loadedSql = sqlFileLoader.load(config, jobParameters);</span>

<span class="nc" id="L97">        log.info(&quot;Source '{}' - SQL ready, {} bind variable(s): {}&quot;,</span>
<span class="nc" id="L98">                config.getName(),</span>
<span class="nc" id="L99">                loadedSql.getParameterNames().size(),</span>
<span class="nc" id="L100">                loadedSql.getParameterNames());</span>

        // ── 2. Resolve DataSource ─────────────────────────────────────────────
<span class="nc" id="L103">        DataSource dataSource = resolveDataSource(config);</span>

        // ── 3. Build RowMapper ────────────────────────────────────────────────
<span class="nc" id="L106">        RowMapper&lt;GenericRecord&gt; rowMapper = buildRowMapper(config);</span>

        // ── 4. Assemble JdbcCursorItemReader ──────────────────────────────────
<span class="nc" id="L109">        JdbcCursorItemReaderBuilder&lt;GenericRecord&gt; builder =</span>
                new JdbcCursorItemReaderBuilder&lt;GenericRecord&gt;()
<span class="nc" id="L111">                        .name(&quot;sqlReader-&quot; + config.getName())</span>
<span class="nc" id="L112">                        .dataSource(dataSource)</span>
<span class="nc" id="L113">                        .sql(loadedSql.getExecutableSql())</span>
<span class="nc" id="L114">                        .fetchSize(config.getEffectiveFetchSize())</span>
<span class="nc" id="L115">                        .rowMapper(rowMapper);</span>

        // Only add setter if there are bound parameters
<span class="nc bnc" id="L118" title="All 2 branches missed.">        if (!loadedSql.getParameterNames().isEmpty()) {</span>
<span class="nc" id="L119">            builder.preparedStatementSetter(loadedSql.getPreparedStatementSetter());</span>
        }

<span class="nc" id="L122">        log.debug(&quot;Source '{}' - JdbcCursorItemReader built (fetchSize={})&quot;,</span>
<span class="nc" id="L123">                config.getName(), config.getEffectiveFetchSize());</span>

<span class="nc" id="L125">        return builder.build();</span>
    }

    // ─────────────────────────────────────────────────────────────────────────
    //  Row Mappers
    // ─────────────────────────────────────────────────────────────────────────

    /**
     * Selects the appropriate RowMapper based on whether columns are declared in the YAML.
     * Explicit mapping (columns declared) = recommended in production.
     * Auto mapping (no columns) = convenient for prototyping.
     */
    private RowMapper&lt;GenericRecord&gt; buildRowMapper(SourceConfig config) {
<span class="nc bnc" id="L138" title="All 4 branches missed.">        boolean hasExplicitColumns = config.getColumns() != null &amp;&amp; !config.getColumns().isEmpty();</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">        if (hasExplicitColumns) {</span>
<span class="nc" id="L140">            log.debug(&quot;Source '{}' - explicit mapping ({} columns)&quot;,</span>
<span class="nc" id="L141">                    config.getName(), config.getColumns().size());</span>
<span class="nc" id="L142">            return new ExplicitColumnRowMapper(config.getColumns());</span>
        }
<span class="nc" id="L144">        log.debug(&quot;Source '{}' - automatic mapping (JDBC metadata)&quot;, config.getName());</span>
<span class="nc" id="L145">        return new AutoColumnRowMapper();</span>
    }

    /**
     * Explicit mapping: reads only the columns declared in the YAML.
     * Advantage: independent of undeclared schema changes.
     */
    private static class ExplicitColumnRowMapper implements RowMapper&lt;GenericRecord&gt; {
        private final List&lt;ColumnConfig&gt; columns;

<span class="nc" id="L155">        ExplicitColumnRowMapper(List&lt;ColumnConfig&gt; columns) {</span>
<span class="nc" id="L156">            this.columns = columns;</span>
<span class="nc" id="L157">        }</span>

        @Override
        public GenericRecord mapRow(ResultSet rs, int rowNum) throws SQLException {
<span class="nc" id="L161">            GenericRecord record = new GenericRecord();</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">            for (ColumnConfig col : columns) {</span>
<span class="nc" id="L163">                String name = col.getName();</span>
                try {
<span class="nc" id="L165">                    record.put(name, rs.getObject(name));</span>
<span class="nc" id="L166">                } catch (SQLException e) {</span>
                    // Column absent from ResultSet → null instead of crash
<span class="nc" id="L168">                    record.put(name, null);</span>
<span class="nc" id="L169">                }</span>
<span class="nc" id="L170">            }</span>
<span class="nc" id="L171">            return record;</span>
        }
    }

    /**
     * Automatic mapping: reads all ResultSet columns via JDBC metadata.
     * Uses COLUMN_LABEL (SQL alias) in priority over COLUMN_NAME.
     */
    private static class AutoColumnRowMapper implements RowMapper&lt;GenericRecord&gt; {
        @Override
        public GenericRecord mapRow(ResultSet rs, int rowNum) throws SQLException {
<span class="nc" id="L182">            GenericRecord record = new GenericRecord();</span>
<span class="nc" id="L183">            ResultSetMetaData meta = rs.getMetaData();</span>
<span class="nc" id="L184">            int count = meta.getColumnCount();</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">            for (int i = 1; i &lt;= count; i++) {</span>
<span class="nc" id="L186">                String label = meta.getColumnLabel(i);</span>
<span class="nc bnc" id="L187" title="All 4 branches missed.">                String name = (label != null &amp;&amp; !label.isBlank()) ? label : meta.getColumnName(i);</span>
<span class="nc" id="L188">                record.put(name, rs.getObject(i));</span>
            }
<span class="nc" id="L190">            return record;</span>
        }
    }

    // ─────────────────────────────────────────────────────────────────────────
    //  Helpers
    // ─────────────────────────────────────────────────────────────────────────

    /**
     * Resolves the DataSource: uses the named bean if {@code dataSourceBean}
     * is defined in the YAML, otherwise uses the primary DataSource.
     */
    private DataSource resolveDataSource(SourceConfig config) {
<span class="nc" id="L203">        String beanName = config.getDataSourceBean();</span>
<span class="nc bnc" id="L204" title="All 4 branches missed.">        if (beanName != null &amp;&amp; !beanName.isBlank()) {</span>
<span class="nc" id="L205">            log.debug(&quot;Source '{}' - named DataSource: '{}'&quot;, config.getName(), beanName);</span>
<span class="nc" id="L206">            return beanFactory.getBean(beanName, DataSource.class);</span>
        }
<span class="nc" id="L208">        log.debug(&quot;Source '{}' - primary DataSource&quot;, config.getName());</span>
<span class="nc" id="L209">        return defaultDataSource;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>