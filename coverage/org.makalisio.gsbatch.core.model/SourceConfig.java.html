<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SourceConfig.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">gsbatch</a> &gt; <a href="index.source.html" class="el_package">org.makalisio.gsbatch.core.model</a> &gt; <span class="el_source">SourceConfig.java</span></div><h1>SourceConfig.java</h1><pre class="source lang-java linenums">// org.makalisio.gsbatch.core.model.SourceConfig
package org.makalisio.gsbatch.core.model;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import java.util.ArrayList;
import java.util.List;

/**
 * Configuration model for a data source.
 * Loaded from YAML files in the ingestion/ directory.
 *
 * @author Makalisio
 * @since 0.0.1
 */
@Getter
<span class="pc" id="L19">@Setter</span>
<span class="nc" id="L20">@ToString</span>
<span class="fc" id="L21">public class SourceConfig {</span>

    /**
     * Name of the source (e.g., &quot;trades&quot;, &quot;orders&quot;)
     */
<span class="fc" id="L26">    private String name;</span>

    /**
     * Type of source: CSV, SQL, JSON, etc.
     */
<span class="fc" id="L31">    private String type;</span>

    /**
     * Chunk size for batch processing (default: 1000)
     */
    private Integer chunkSize;

    // ── CSV ──────────────────────────────────────────────────────────────────

    /** Chemin vers le fichier CSV */
<span class="nc" id="L41">    private String path;</span>

    /** Delimiteur CSV (defaut : &quot;;&quot;) */
<span class="pc" id="L44">    private String delimiter = &quot;;&quot;;</span>

    /** Ignorer la ligne d'en-tete (defaut : true) */
<span class="pc" id="L47">    private boolean skipHeader = true;</span>

    /** Liste des colonnes */
<span class="fc" id="L50">    private List&lt;ColumnConfig&gt; columns = new ArrayList&lt;&gt;();</span>

    // ── SQL ──────────────────────────────────────────────────────────────────

    /**
     * Repertoire contenant les fichiers SQL.
     * Peut etre absolu (ex : /data/sql) ou relatif au classpath.
     * Exemple : /opt/batch/sql  ou  D:/work/sql
     */
<span class="fc" id="L59">    private String sqlDirectory;</span>

    /**
     * Nom du fichier SQL dans le sqlDirectory.
     * Exemple : orders_new.sql
     *
     * Le fichier peut contenir des variables bindees de la forme :paramName
     * dont les valeurs sont transmises via les jobParameters.
     *
     * Exemple :
     *   SELECT * FROM ORDERS
     *   WHERE status = :status
     *     AND trade_date = :process_date
     *
     * Lancement : java -jar app.jar sourceName=orders status=NEW process_date=2024-01-15
     */
<span class="fc" id="L75">    private String sqlFile;</span>

    /**
     * Nombre de lignes chargees par batch JDBC (fetchSize).
     * Impacte la memoire et les performances. Defaut : 1000.
     */
<span class="nc" id="L81">    private Integer fetchSize;</span>

    /**
     * Bean name de la DataSource a utiliser si plusieurs sources de donnees
     * sont declarees dans le backoffice. Optionnel  - utilise la DataSource
     * principale par defaut.
     */
<span class="nc" id="L88">    private String dataSourceBean;</span>

    /**
     * Retourne le fetchSize, avec 1000 comme valeur par defaut.
     *
     * @return fetchSize effectif
     */
    public int getEffectiveFetchSize() {
<span class="fc bfc" id="L96" title="All 4 branches covered.">        return fetchSize != null &amp;&amp; fetchSize &gt; 0 ? fetchSize : 1000;</span>
    }

    // ── REST API CONFIGURATION ───────────────────────────────────────────────

    /**
     * REST API configuration (required when type=REST).
     * Contains URL, authentication, pagination, and JSON extraction settings.
     */
<span class="nc" id="L105">    private RestConfig rest;</span>

    /**
     * Indicates if this source has REST configuration.
     *
     * @return {@code true} if {@code rest} is defined
     */
    public boolean hasRestConfig() {
<span class="fc bfc" id="L113" title="All 2 branches covered.">        return rest != null;</span>
    }

    // ── SOAP WEBSERVICE CONFIGURATION ────────────────────────────────────────

    /**
     * SOAP WebService configuration (required when type=SOAP).
     * Contains endpoint, authentication, and XPath extraction settings.
     */
<span class="nc" id="L122">    private SoapConfig soap;</span>

    /**
     * Indicates if this source has SOAP configuration.
     *
     * @return {@code true} if {@code soap} is defined
     */
    public boolean hasSoapConfig() {
<span class="fc bfc" id="L130" title="All 2 branches covered.">        return soap != null;</span>
    }

    // ── STEPS PRE/POST PROCESSING ────────────────────────────────────────────

    /**
     * Configuration de la step de pre-processing (optionnelle).
     * Executee avant la step de lecture/ecriture chunk.
     */
<span class="pc" id="L139">    private StepConfig preprocessing = new StepConfig();</span>

    /**
     * Configuration de la step de post-processing (optionnelle).
     * Executee apres la step de lecture/ecriture chunk.
     */
<span class="pc" id="L145">    private StepConfig postprocessing = new StepConfig();</span>

    // ── WRITER GENERIQUE ─────────────────────────────────────────────────────

    /**
     * Configuration du writer.
     * Si absent, le framework cherche un bean &quot;{sourceName}Writer&quot; dans le contexte Spring.
     */
<span class="fc" id="L153">    private WriterConfig writer;</span>

    /**
     * Indique si le writer est configure de maniere declarative dans le YAML.
     *
     * @return {@code true} si {@code writer} est defini
     */
    public boolean hasWriterConfig() {
<span class="fc bfc" id="L161" title="All 2 branches covered.">        return writer != null;</span>
    }

    /**
     * Gets the chunk size, returning 1000 if not configured.
     *
     * @return the chunk size
     */
    public Integer getChunkSize() {
<span class="fc bfc" id="L170" title="All 4 branches covered.">        return chunkSize != null &amp;&amp; chunkSize &gt; 0 ? chunkSize : 1000;</span>
    }

    /**
     * Extracts column names as a String array.
     *
     * @return array of column names
     */
    public String[] getColumnNames() {
<span class="pc bpc" id="L179" title="1 of 4 branches missed.">        if (columns == null || columns.isEmpty()) {</span>
<span class="fc" id="L180">            return new String[0];</span>
        }
<span class="fc" id="L182">        return columns.stream()</span>
<span class="fc" id="L183">                .map(ColumnConfig::getName)</span>
<span class="fc" id="L184">                .toArray(String[]::new);</span>
    }

    /**
     * Validates the configuration.
     *
     * @throws IllegalStateException if validation fails
     */
    public void validate() {
<span class="fc bfc" id="L193" title="All 4 branches covered.">        if (name == null || name.isBlank()) {</span>
<span class="fc" id="L194">            throw new IllegalStateException(&quot;Source name is required&quot;);</span>
        }
        
<span class="pc bpc" id="L197" title="1 of 4 branches missed.">        if (type == null || type.isBlank()) {</span>
<span class="fc" id="L198">            throw new IllegalStateException(&quot;Source type is required for source: &quot; + name);</span>
        }

        // ── Validation CSV ───────────────────────────────────────────────────
<span class="fc bfc" id="L202" title="All 2 branches covered.">        if (&quot;CSV&quot;.equalsIgnoreCase(type)) {</span>
<span class="pc bpc" id="L203" title="1 of 4 branches missed.">            if (path == null || path.isBlank()) {</span>
<span class="fc" id="L204">                throw new IllegalStateException(&quot;Path is required for CSV source: &quot; + name);</span>
            }
<span class="pc bpc" id="L206" title="1 of 4 branches missed.">            if (columns == null || columns.isEmpty()) {</span>
<span class="fc" id="L207">                throw new IllegalStateException(&quot;Columns configuration is required for CSV source: &quot; + name);</span>
            }
<span class="fc bfc" id="L209" title="All 2 branches covered.">            for (int i = 0; i &lt; columns.size(); i++) {</span>
<span class="fc" id="L210">                ColumnConfig col = columns.get(i);</span>
<span class="pc bpc" id="L211" title="1 of 4 branches missed.">                if (col.getName() == null || col.getName().isBlank()) {</span>
<span class="fc" id="L212">                    throw new IllegalStateException(</span>
<span class="fc" id="L213">                        String.format(&quot;Column name is required at index %d for source: %s&quot;, i, name)</span>
                    );
                }
            }
        }

        // ── Validation SQL ───────────────────────────────────────────────────
<span class="fc bfc" id="L220" title="All 2 branches covered.">        if (&quot;SQL&quot;.equalsIgnoreCase(type)) {</span>
<span class="pc bpc" id="L221" title="1 of 4 branches missed.">            if (sqlDirectory == null || sqlDirectory.isBlank()) {</span>
<span class="fc" id="L222">                throw new IllegalStateException(&quot;sqlDirectory is required for SQL source: &quot; + name);</span>
            }
<span class="pc bpc" id="L224" title="1 of 4 branches missed.">            if (sqlFile == null || sqlFile.isBlank()) {</span>
<span class="fc" id="L225">                throw new IllegalStateException(&quot;sqlFile is required for SQL source: &quot; + name);</span>
            }
        }

        // ── Validation REST ──────────────────────────────────────────────────
<span class="fc bfc" id="L230" title="All 2 branches covered.">        if (&quot;REST&quot;.equalsIgnoreCase(type)) {</span>
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">            if (rest == null) {</span>
<span class="fc" id="L232">                throw new IllegalStateException(&quot;rest configuration is required for REST source: &quot; + name);</span>
            }
<span class="nc" id="L234">            rest.validate();</span>
        }

        // ── Validation SOAP ──────────────────────────────────────────────────
<span class="fc bfc" id="L238" title="All 2 branches covered.">        if (&quot;SOAP&quot;.equalsIgnoreCase(type)) {</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">            if (soap == null) {</span>
<span class="fc" id="L240">                throw new IllegalStateException(&quot;soap configuration is required for SOAP source: &quot; + name);</span>
            }
<span class="nc" id="L242">            soap.validate();</span>
        }
        
<span class="fc bfc" id="L245" title="All 4 branches covered.">        if (chunkSize != null &amp;&amp; chunkSize &lt;= 0) {</span>
<span class="fc" id="L246">            throw new IllegalStateException(&quot;Chunk size must be positive for source: &quot; + name);</span>
        }

        // ── Validation pre/post processing ───────────────────────────────────
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        if (preprocessing != null) {</span>
<span class="fc" id="L251">            preprocessing.validate(&quot;preprocessing&quot;);</span>
        }
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">        if (postprocessing != null) {</span>
<span class="fc" id="L254">            postprocessing.validate(&quot;postprocessing&quot;);</span>
        }

        // ── Validation writer declaratif ─────────────────────────────────────
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">        if (writer != null) {</span>
<span class="nc" id="L259">            writer.validate();</span>
        }
<span class="fc" id="L261">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>